---
layout:     post
title:      "shader入门"
subtitle:   "阅读《Unity Shader入门精要》一书摘录与思考"
date:       2022-1-08
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - gc
---
- 渲染流水线
    - 三个阶段
        - 应用阶段(开发者具有这阶段的绝对控制权)
            - 通常由CPU负责
            - 重点输出:**渲染图元**,通俗说,渲染图元是点 线 三角面等
            - 三个任务
                - 准备好场景数据,如:摄像机位置 视锥体 场景中的模型 与光源
                - 粗粒度剔除工作,把不可见物体剔除
                - 设置每个模型的渲染状态,如:材质 物理 shader等
            - 三个阶段
                - 把数据加载到显存中
                    - 渲染所需数据从硬盘读取到系统内存,再被加载到显卡上的存储空间(显存)
                    - 为什么要加载到显存
                        - 显卡对显存的访问速度更快,且多数显卡对应系统内存没有直接访问权力
                - 设置渲染状态
                    - 使用哪个**顶点着色器 片源着色器 纹理 材质**等,如果没有更改渲染状态,则使用同一个渲染状态
                - 调用DrawCall
                    - 是什么
                        - 根据第一阶段的输入顶点数据准备和第二阶段的渲染状态设置进行渲染,渲染命令就是DrawCall
                        - 从CPU发起,GPU接收并计算,最终输出成屏幕上显示的像素
                        - 一个DrawCall会直想本次调用需要渲染的图元列表
        - 几何阶段
            - 通常用GPU负责
            - 主要任务:把渲染图元进行多部处理,**输出屏幕空间的二维顶点坐标,每个顶点对应的深度值,着色等信息**
        - 光栅化阶段
            - GPU负责
            - 主要任务:决定每个渲染图元中的哪些像素应该被绘制在屏幕上
                - 怎么做
                    - **逐顶点**数据(纹理坐标 顶点颜色等)进行**插值**,再进行**逐像素**处理
    - 几何阶段和光栅阶段可以分成以下GPU流水线
        - 绿色:完全可编程控制,黄色:可以配置不可编程,蓝色:GPU固定实现,开发者无控制权
        ![GPU流水线](/img/in-post/post-js-version/shader/shader_1.png)
        - 几何阶段
            - 顶点着色器
                - 作用:用于实现顶点的**坐标变换**,顶点着色等
                    - 坐标变换是什么
                        - 通过改变顶点位置模拟水面布料
                        - 把顶点坐标从模型空间转换到**齐次裁剪**空间
                            - 齐次裁剪是什么
                - 怎么做
                    - 输入进来的每个顶点都会调用一次顶点着色器
            - 曲面细分着色器(可选,作用:细分图元) 几何着色器 (可选,作用:逐图元着色操作)
            - 裁剪: 不在摄像机视野内的顶点裁剪,并剔除某些三角图元的面片
                - 部分在视野内的图元需要裁剪,生成新的顶点(位于事业边界的交点处)
            - 屏幕映射:每个图元的坐标转换到屏幕坐标系中(**缩放**过程)
        - 光栅阶段(输入:屏幕坐标系的顶点以及顶点额外信息,如深度z,法线,视角等)
            - 目标:计算每个图元覆盖了哪些像素,为这些像素计算颜色
            - 步骤
                - 三角形设置
                    - 为什么生成三角形
                        - 为了得到三角网格对像素的覆盖情况,必须计算每条边上的像素坐标,所以需要得到三角形边界的表示方式
                - 三角形遍历
                    - 过程:检查每个像素是否被一个三角网格所覆盖,如果覆盖则生成一个**片元**
                        - 什么是片元?
                            - 包含了多个状态的几何,这些状态用于计算每个像素的最终颜色,包括 屏幕坐标,深度信息等
                - 片元着色器
                    - 过程
                        - 根据那些从顶点着色器输出的3个顶点的纹理纹理坐标插值得到片元的纹理坐标
                - 逐片元操作:修改颜色 ,深度缓存,进行混合(真正对像素产生影响的步骤)
                    - opengl称为逐片元,DirectX称为**输出合并阶段**
                    - 合并什么数据
                    - 进行什么操作
                    - 过程
                        - 片元->模板测试->深度测试->混合->颜色缓冲区
                    - 主要任务
                        - 决定每个片元的可见性,涉及测试工作,如模板测试,深度测试等
                        - 如果通过所有测试,需要把该片元的颜色值和已经存储在颜色缓冲区中的颜色进行**合并**
                    - 颜色缓冲区
                        - 为了避免看到正在进行光栅化的图元,GPU使用双重缓冲的策略

- HLSL GLSL CG
    - DireceX 的HLSL
        - 优点
            - 就算使用不同硬件,同一个着色器编译结果一样(前提版本一致)
        - 缺点
            - 仅支持微软产品
    - OpenGL的GLSL
        - 优点
            - 跨平台
        - 缺点
            - 由硬件提供商觉得编译结果,可能编译实现不一致
    - NVIDIA的CG
        - 根据平台不同,编译程相应的中间语言
        - 跨平台取决于与微软的合作,CG语法与HLSL相似
- Unity Shader
    - 是什么
        - Unity Shader为控制渲染过程提供了一层抽象,如果没有使用Unity Shader,开发者需要和很多文件和设置打交道,才能让画面呈现出想要的消锅
- ShaderLab
    - 在Unity Shader的帮助下,开发者只需要使用ShaderLab来编写就可以完成所有工作
    - 基础结构

        ```shader
        Shader "ShaderName" {
            // 属性
            Properties {
                //Name ("display name", PropertyType) = DefaultValue
                //PropertyType:Int,Float,Range(min, max),Color,Vector,2D,Cube,3D
            }
            // 显卡A使用的子着色器
            SubShader {
                //标签,是一个键值对,键和值都是字符串,可选
                Tags = {}
                // 状态,可选,如:设置提出模式,深度测试使用的函数,开关深度写入,开关混合模式
                RenderSetup = {}
                //如果在SubShader设置标签和状态,会应用于所有Pass
                pass = {
                    name = "MyPassName"
                    // 可选
                    tags = {}
                    // 可选
                    RenderSetup ={}
                }
            }
            //多个子着色器
            FallBack "VertexList" //如果上述所有SubShader在这块显卡上都不能运行,就用这个最低级别的
        }
        ```
    - SubShader的形式
        - 表面着色器 sufrface,在SubShader实现
            - 是什么? Unity自己创造的一种着色器代码类型,是Unity对顶点/片元着色器的更高一层的抽象,背后会转换成对应的顶点/片元着色器
        - 顶点/片元着色器 vertex fragment, 在各个Pass中实现
            - 怎么写?
                - 内嵌CG/HLSL语言进行编写,嵌套在CGPROGRAM 和ENDCG之间
        - 固定函数着色器, 几乎弃用

- 数学基础
    - 笛卡尔坐标系
    - 左手坐标系 Unity
        - 大拇指x,中指z,食指y
    - 点乘,结果是数
        - 公式
            - a · b = |a||b|cosθ
            - a · b = (x1, y1, z1) · (x2, y2, z2) = x1x2 +y1y2+z1z2
        - 几何意义
            - 可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影
    - 叉乘, 结果是向量
        - 公式
        ![叉乘公式](/img/in-post/post-js-version/shader/shader_2.png)
        - a X b的长度等于a和b的模的乘积再乘以他们之间夹角的正弦值
            - |a X b| = |a||b|sinθ

        - 几何意义
            - 得到一个同事垂直于这两个是矢量的新矢量
            - 判断三角面片的朝向
        - 如何选择新矢量的方向,使用右手坐标系
        ![叉乘方向](/img/in-post/post-js-version/shader/shader_3.png)
    - 矩阵
        - 矩阵与标量相乘,矩阵的每个元素与标量相乘,得到一个相同维度的矩阵
        - 矩阵相乘
            - r X n 的矩阵A和n X c 的矩阵B相乘,结果AB为r X c 大小的矩阵,
            必须支持第一个矩阵的列数必须和第二个矩阵的行数相同,结果矩阵,行数为第一个矩阵的行数,列数为第二个矩阵的列数
        - 方块矩阵: n X n
            - 对角矩阵
                - 单位矩阵 I
            - 逆矩阵 : M X M-1 = I ,M-1表示M的逆矩阵
        - 转置矩阵:r X c => c X r