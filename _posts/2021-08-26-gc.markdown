---
layout:     post
title:      "垃圾回收"
subtitle:   "阅读《垃圾回收的算法与实现》一书摘录与思考"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - gc
---
- 算法篇
    - GC的历史
        - 1960年john McCarthy发布了GC标记-清除算法的论文，会检查所有的活动和非活动对象
        - 1960年Geirge E.Collins在论文发布了叫做引用技术的GC算法
            - 有个缺点，不能回收“循环利用”，两个或以上对象循环互相引用
        - 1963年 Marvin L.Minsky在论文发布了复制算法。GC复制算法把内存分成两部分,GC复制算法只检查活动对象。
        > 后续的算法发布基本上实在这三种算法进行组合和应用
    - 学习GC之前
        - 对象是GC的基本单位，对象由“头”和“域”组成
            - 将对象中保存对象本身信息的部分成为头，头主要包含以下信息
                - 对象的大小
                - 对象的种类
            - 把对象使用者在对象中可访问的部分称为“域”，域中的数据类型大致分为：
                - 指针（指向内存中某块区域的值）
                - 非指针（在编程中直接使用的值本身）
            > 对象使用者会引用或替换对象的域值。头之后存在一个及一个以上的域。
![对象、头、域](http://csoap.github.io/img/in-post/post-js-version/gc_1.png "对象、头、域")
        - 指针如果指向对象首地址以为的部分，GC就变得很复杂。在大多数语言处理程序中，**指针都默认指向对象的首地址**，因此在文章下述描述中以此为前提。
        - mutator ，一句话概括，它的实体就是“应用程序”，mutator实际进行的操作有：
            - 生成对象
            - 更新指针
        - 分配。
            - 分配指的是在内存空间中分配对象，当mutator需要新对象时，就会像分配器申请一个大小合适的空间，分配器则在堆的可用空间中找寻满足要求的空间，返回给mutator。
            - 当堆被所有对象占满时候，有两种选择
                - 输出错误信息
                - 扩大堆，现实的执行环境一般选择这种。
        - 分块
            - 分块在GC的世界里指的是为利用对象而事先准备的空间。
            - 初始状态下，堆被一个大的分块所占据。然后程序根据mutator的要求把这个分块分割成合适的大小，作为活动对象使用。活动对象不久后转为垃圾被回收，被回收的内存空间再次成为分块，为下次利用做准备。内存中的各个区块一直**重复**这个过程
        - 根(root)
            - 在GC的世界，根是指向对象的指针的“起点”部分。
             ```
             $obj = Object.new //对象A
             $obj.field1 = Object.new //对象那个B
             ```
             - 我们可以通过$obj直接从为代码中引用对象A，也就是说A是活动对象。此外，因为可以通过$obj经由对象A引用对象B，所以对象B也是活动对象。因此GC必须保护这些对象.
             - $obj是全局对象，在这里，$obj 就是根。
        - 评价GC算法的性能，采用以下4种标准。
            - 吞吐量
                - 单位时间内的处理能力。在mutator整个执行过程中，假设GC一共启动了3次，分别耗时A、B、C，在大小为HEAP_SIZE的堆进行内存管理，此情况下的吞吐量为HEAP_SIZE/(A+B+C)
            - 最大暂停时间
                - 因执行GC而暂停执行Muatator的最长时间。较大的吞吐量和较短的最大暂停时间不可兼得，应根据执行的应用所重视的指标的不同，来分别采用不同的GC算法
            - 堆使用效率
                - 使用效率：1.头的大小，头越小越好。2.堆的用法。 因为GC是自动内存管理功能，所以如果GC过量占用堆就成了本末倒置。
            - 访问的局部性
                - PC有4种存储器，寄存器、缓存、内存、辅助存储器（硬盘等）。小容量、高速 =》 大容量、低速
                - 具有引用关系的对象之间通常很有可能存在连续访问的情况。把具有引用关系的对象安排在堆种较近的位置，就能提高在缓存中读取到想利用的数据的概率。

    - GC标记-清除算法
        - what？由标记阶段和清除阶段组成。标记是把所有活动对象做上标记，清除是把非活动对象回收的阶段。
        - 标记
            - 首先要标记通过根直接引用的对象。递归地标记通过指针能访问到的对象，这边使用的是深度优先搜索。
            > 比较一下内存使用量（已存储的对象数量）就可以知道，深度优先搜索比广度优先搜索更能压低内存使用量。因此我们在标记阶段经常用到深度优先搜索。
            ```
            mark_phase(){
                for(r : $roots)
                mark(*r)
            }

            mark(obj){
                if(obj.mark == FALSE)
                obj.mark = TRUE
                for(child : children(obj))
                mark(*child)
            }
            ```
            ![设置标志位的处理](http://csoap.github.io/img/in-post/post-js-version/gc_2.png "设置标志位的处理")
        - 清除
- 实现篇
    - python的垃圾回收

