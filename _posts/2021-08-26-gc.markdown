---
layout:     post
title:      "垃圾回收"
subtitle:   "阅读《垃圾回收的算法与实现》一书摘录与思考"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - gc
---
- 算法篇
    - GC的历史
        - 1960年john McCarthy发布了GC标记-清除算法的论文
        - 1960年Geirge E.Collins在论文发布了叫做引用技术的GC算法
            - 有个缺点，不能回收“循环利用”，两个或以上对象循环互相引用
        - 1963年 Marvin L.Minsky在论文发布了复制算法。GC复制算法把内存分成两部分
        > 后续的算法发布基本上实在这三种算法进行组合和应用
    - 学习GC之前
        - 对象是GC的基本单位，对象由“头”和“域”组成
            - 将对象中保存对象本身信息的部分成为头，头主要包含以下信息
                - 对象的大小
                - 对象的种类
            - 把对象使用者在对象中可访问的部分称为“域”，域中的数据类型大致分为：
                - 指针（指向内存中某块区域的值）
                - 非指针（在编程中直接使用的值本身）
            > 对象使用者会引用或替换对象的域值。头之后存在一个及一个以上的域。
![对象、头、域](http://csoap.github.io/img/in-post/post-js-version/gc_1.png "对象、头、域")
        - 指针如果指向对象首地址以为的部分，GC就变得很复杂。在大多数语言处理程序中，**指针都默认指向对象的首地址**，因此在文章下述描述中以此为前提。
        - mutator ，一句话概括，它的实体就是“应用程序”，mutator实际进行的操作有：
            - 生成对象
            - 更新指针
        - 分配。
            - 分配指的是在内存空间中分配对象，当mutator需要新对象时，就会像分配器申请一个大小合适的空间，分配器则在堆的可用空间中找寻满足要求的空间，返回给mutator。
            - 当堆被所有对象占满时候，有两种选择
                - 输出错误信息
                - 扩大堆，现实的执行环境一般选择这种。
        - 分块
            - 分块在GC的世界里指的是为利用对象而事先准备的空间。
            - 初始状态下，堆被一个大的分块所占据。然后程序根据mutator的要求把这个分块分割成合适的大小，作为活动对象使用。活动对象不久后转为垃圾被回收，被回收的内存空间再次成为分块，为下次利用做准备。内存中的各个区块一直**重复**这个过程
        - 根(root)
            - 在GC的世界，根是指向对象的指针的“起点”部分。
             ```
             $obj = Object.new //对象A
             $obj.field1 = Object.new //对象那个B
             ```
             - 我们可以通过$obj直接从为代码中引用对象A，也就是说A是活动对象。此外，因为可以通过$obj经由对象A引用对象B，所以对象B也是活动对象。因此GC必须保护这些对象.
             - $obj是全局对象，在这里，$obj 就是根。
        - 评价GC算法的性能，采用以下4种标准。
            - 吞吐量
            - 最大暂停时间
            - 堆使用效率
            - 访问的局部性

- 实现篇
    - python的垃圾回收

