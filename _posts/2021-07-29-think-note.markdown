---
layout:     post
title:      "灯泡时刻（不定期更新）"
subtitle:   "突然对某个技术点有疑问的逼技"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - 其他
---

阅读清单
- untiy游戏 C#和lua是如何交互的？
- 代码调用栈原理
- 协程底层原理
    > unity有多条渲染线程，但是对于代码的调度是在一个主线程，协程是靠操作系统在主线程的调度实现的
    - 实现原理
        - yield 相当是暂停本次生命周期执行，或者是转移控制权给unity继续生命周期
            - 每次执行到yield 暂停一下，然后下次又继续执行 如何实现？ 本质上是通过IEnumetator.MoveNext()实现的
        - 生成一个CountCoroutine的类,本质是状态机。构造方法会设置一个初始状态state为0，当state != 1 结束协程。这个类持有一个NevBehaviourScript的脚本对象，也就是为什么访问到脚本对象的各个字段
    - 协程的缺点
        - 依赖于MonoBehaviour
            - 大型商业游戏很有可能脚本不会继承自MonoBehaviour
            - MVC框架，基本只有V跟monoBehaviour打交道，M和C基本不会打交道，如果想在M或C启动协程（例：计算buff持续伤害等）就会有问题。
            - 怎么解决？实现一个自定义调度器，怎么实现？需要了解一下
        - 不能有返回值
        - 回调地狱，回调层数多了以后维护起来太复杂。。
            - 例子：如果需求是下载一张图片后下载另一张，持续很多张图片，就变成俄罗斯套娃了。
            ```
            hw.GET("xxx", (www1) =>
            {
                hw.Get("yyy", (www2)=>
                {

                });
            });

            //怎么解决，改成用 Async/Await? await什么原理?又需要去了解了。。
            await hw.Get("xxx");
            //do something
            await hw.Get("yyy");
            //do something
            ```
    - 协程有什么坑点
        - 协程的停止和创建必须用相同形式。字符串、IEnumerator、Coroutine形式
        - 禁用脚本(this.enabled = false)不会停止协程执行
        - 删除脚本（Destory(this)）或禁用GameObject会停止协程执行
- mvc?
- 模拟unity管理GameObject上Mono组件的生命周期？
    - Mono是什么？包含了实现特定脚本函数的组件类
    - 组件时什么？组件在unity中是如何实现？gameobjet是组件的容器
    - 生命周期是什么？unity 是如何管理生命周期，本质上通过遍历
    - unity 引擎是什么？管理项目中的资源+程序运行中的游戏对象树

- 快排的时间复杂度和具体实现
- 一篇英文文章，求每个单词的出现频率？算法的时间复杂度是多少？优化这个算法，能否加快这个过程？
- c#中，ArrayList和list，dictionary和hashtable区别，dictionary的底层实现原理
    - https://www.cnblogs.com/yiyi20120822/p/11429137.html
    https://www.cnblogs.com/TiestoRay/p/4891026.html
    - Dictionary与Hashtable
        - 数据结构上来说都属于Hashtable, 都是对关键字（键值）进行散列操作,将关键字散列到Hashtable的某一个槽位中去，不同的是处理碰撞的方法
        > Dictionary采用链表法处理碰撞,通过Hash算法来碰撞到指定的Bucket上，碰撞到同一个Bucket槽上所有数据形成一个单链表。
        ```
        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;
        //将HashCode的返回值转化为数组索引
        int bucketIndex = hashCode % buckets.Length;
        ```
        HashTable采用开放寻址法方法中的双重散列处理碰撞
        - dictionary
            - 有泛型优势（类型安全，性能更好），对于值类型，不存在装箱和拆箱的性能损耗
            - 读取速度快（体现在单条数据上）
            - 容量利用更充分
            - 非线程安全,多线程必须人为使用 lock 语句进行保护,  效率大减.
            - 有序（遍历时输出的顺序就是加入的顺序）
        - hashtable
            - 适合多线程
            - 通过静态方法Synchronize方法可获得完全线程安全的类型
            - 无序
    - List与Dictionary
        - List有点类似于Dictionary。二者都具有使用泛型的优点(联想到ArrayList)，Dictionary没有在内存中移动后续元素的性能开销。
        > ArrayList是可变长数组，你可以将任意多的数据Add到ArrayList里面。其内部维护的数组，当长度不足时，会自动扩容为原来的两倍。但是ArrayList也有一个缺点，就是存入ArrayList里面的数据都是Object类型的，所以如果将值类型存入和取出的时候会发生装箱、拆箱操作(就是值类型与引用类型之间的转换)，这个会影响程序性能。在.Net 2.0泛型出现以后，就提供了List<T>。List<T>是ArrayList的泛型版本，它不再需要装箱拆箱，直接取，直接用
        - List是在数组的基础上做的封装,本质是有序的动态数组，遍历查询更快(数据较多时)，Dictionary单条查询更快
        > 同样是集合，为什么性能会有这样的差距。我们要从存储结构和操作系统的原理谈起。首先我们清楚List<T>是对数组做了一层包装，我们在数据结构上称之为线性表，而线性表的概念是，在内存中的连续区域，除了首节点和尾节点外，每个节点都有着其唯一的前驱结点和后续节点。我们在这里关注的是连续这个概念。而HashTable或者Dictionary，他是根据Key和Hash算法分析产生的内存地址，因此在宏观上是不连续的，虽然微软对其算法也进行了很大的优化。由于这样的不连续，在遍历时，Dictionary必然会产生大量的内存换页操作，而List只需要进行最少的内存换页即可，这就是List和Dictionary在遍历时效率差异的根本原因。
        >> 在这里我们除了刚才的遍历问题，还要提到Dictionary的存储空间问题，在Dictionary中，除了要存储我们实际需要的Value外，还需要一个辅助变量Key，这就造成了内存空间的双重浪费。而且在尾部插入时，List只需要在其原有的地址基础上向后延续存储即可，而Dictionary却需要经过复杂的Hash计算，这也是性能损耗的地方。

- 一个数组，求前k大的数值。时间复杂度是多少。
    - 暴力法。先将数组排序（nlogn），如果是从大到小，返回第K个，如果从小到大，返回第n-k个（n表示元素个数）
    - 优先队列priorityQueue，内部实现是维护一个大小为k的最小堆。
    - 快速选择算法（快排）
- 打动态图集有什么规范？图片的压缩格式用什么？背包商店的图片怎么打成图集是最优的？动态图集的大小是怎么设定的？使用动态图集有什么缺点？图集能不能做缓存?缓存的策略是什么？
- ui框架实现了什么功能？如何管理面板层级关系，遮挡关系，互斥关系？如何做缓存策略？
- 如果ui界面打开比较慢，有可能有什么问题。
    - 第一次加载慢，什么问题？
    - 第二次加载慢？
- 一个界面打开的时候ui动画应该怎么做效率最高？
- 背包一滚动 就卡?
- 断线重连? 对于帧同步、状态同步处理方法是不一样的
    - 状态同步需要恢复游戏的状态数据。
    - 帧同步需要从第一帧开始追帧到当前最新游戏帧。如何实现？
- 战斗系统怎么实现？
    - 如果放了一个技能，如何判定对方是否收到伤害？
    - 收到伤害如何做飘出伤害文字？伤害文字怎么优化？

- 性能优化
    - GC
        - 垃圾是怎么产生的？
        - 为什么要进行垃圾收集？
        - 垃圾收集放在什么时间点比较合适？
        - 如何成代码设计的角度避免垃圾的产生？
    - 内存管理
        - 在C#中分堆内存 栈内存，有什么区别？
        - 内存中还分成mono管理（托管堆）的内存、资源内存、代码内存管理。
        - drawcall 优化
        - 耗电问题怎么优化

- unity 热更新的底层原理？ Scripting Backend 脚本引擎后台是什么？
    参考视频讲解：https://www.bilibili.com/video/BV1Ra411c7Gz
    - 打包选项，有两种
        - Mono
            - ARMv7、x86
            - 只支持32位系统，内存最大4G, 2^32 = 4G
            - 打包后apk修改后缀为.zip，查看项目目录结构，是.dll（动态链接库,此为项目脚本文件）后缀的文件 + mono虚拟机文件(limonoXXX.so文件),.dll文件必须加载到mono虚拟机文件中执行。
        - IL2CPP
            - ARMv7、ARM64、x86
            - 支持32位、64位系统
            - 打包后无DLL文件，libil2cpp.so = libmono.so + Assembly-CSharp.dll
            - 可以显著减少构建的游戏包体大小
            - 必须提前编译
        - android 支持 Mono 和IL2CPP
        - ios 仅支持IL2CPP，此外大部分平台仅支持IL2CPP
        > ios在早期是支持Mono的Full-AOT方式，仅支持32位，但是在2016年1月平台要求所有新上架的游戏必须支持64位架构，所以必须要选IL2CPP。
    - Mono方式脚本编译流程
        - 脚本被编译成IL
            - C#code 通过Mono C# Compiler编译生成CIL(中间汇编语言，不同平台的CIL可能不一样)，在游戏运行时候，IL和项目里其他的第三方兼容的DLL一起放入Mono VM虚拟机，由虚拟机解析成机器码，并且执行。
            - 等到需要真正执行的时候，这些IL会被加载到运行时库，也就是VM中，由VM动态的编译程汇编代码（JIT）再执行
        - CLI = CIL + CLR
        ![编译流程图](http://csoap.github.io/img/in-post/post-js-version/mono-complier.png "编译流程图")
            - 编译：通过C#编译器，运行前把C#编译成CIL（实现平台无关汇编）
            - 运行：通过CLR，在运行时把CIL转换成各平台的原生码
            >  CLI: Common Language Infrastructure 公共语言基础结构 | CIL: Common Intermediate Language 公共中间语言 | CLR: Common Language Runtime
        - CRL 通用语言平台，是微软的.Net虚拟机
            - 抽象了平台相关部分，因为windows、linux、android等操作系统的以下行为是不一样的（如进程线程管理、内存分配、垃圾回收、文件管理等），并在运行时调用平台相关的实现。
        - Mono
            - 一个基于CLR的开源项目，运行引擎和用户的托管代码运行在每一个目标平台上
            - 微软的传统虚拟机叫做.NET平台虚拟机，本身是不支持跨平台的，经过mono的移植，才可以支持跨平台。unity也是利用mono这个开源项目实现跨平台
        - Mono虚拟机如何运行CIL？
            - JIT（Just In Time）模式。在编译的时候，把C#编译成CIL，在运行时，逐条读入，逐条解析成原生码交给CPU再执行
            - AOT（Ahead Of Time）模式。在编译程CIL之后，会把CIL再处理一边，编译成原生码，在运行的时候交给CPU直接执行，Mono下的AOT只会处理部分的CIL，还有一部分CIL采用JIT的模式
            - Full AOT。在编程CIL之后，把所有的CIL编译成原生码，在运行时的时候直接执行
                - 不允许运行时动态加载代码了，也就是说**不支持热更**，如ios只支持Full AOT,andorid支持三种。
                - 安全性比较好
    - IL2CPP方式脚本编译流程
        ![IL2CPP编译流程图](http://csoap.github.io/img/in-post/post-js-version/il2cpp-complier.png "IL2CPP编译流程图")
        - C#code 通过Mono C# Compiler编译生成CIL，通过IL2CPP将CIL重新编程C++代码，然后再由各个平台的C++编译器（例:x86：vc++,linux、android:gcc）直接编译程能执行的原生汇编代码,然后通过IL2CPP VM虚拟机生成机器码
        - 仅支持AOT方式
    - 理想的热更流程
        - 热更的功能写在一个DLL中
        - 游戏启动时用新的同名DLL覆盖旧的
        - Assembly.Load动态加载该DLL
        - 反射创建热更DLL中的类的实例或静态方法
        - 这么简单？理论上android支持jit，所以是可以的。但是ios不支持，因为ios禁止为动态分配内存赋予执行权限
    ```C++
    void* create_space(size_t size) {
        void* ptr = mmap(0, size, PROT_READ | PROT_WRITE | PROT_EXEC，
                MAP_PRIVATE | MAP_ANON, -1, 0);
        return ptr;
    }
    // 本段C++代码相当于创建一块内存，并未内存赋予权限，在windows、android上是正常的。
    //在ios平台上会报错，ios禁止为动态创建的内存赋予执行权限，PROT_EXEC是禁止的。
    ```
    - 所以只能采用静态编译
        - Mono的Full-AOT
        - IL2CPP
        - 但也不能完全避免问题。在IOS平台上运行的程序,如果在运行的时候才知道泛型的实际类型，用上述2种编译会直接跳过这段代码的编译，编译器会认为说我既然是静态编译的，就不能执行在程序运行中动态指令的代码，会导致报错，如下：

        ![ios代码](http://csoap.github.io/img/in-post/post-js-version/complier-ios.png "ios代码")
        - 怎么解决？
            - 比较不好的解决方法。强制AOT生成具象类型代码，这样就丧失的泛型的灵活性。如：OnMessage(AnyEnum.Zero);需要思考有没有更好的办法？思考kow项目中tolua 是怎么解决的
    - 解决方案
        - 所以要嵌入脚本语言
            - lua
                - ToLua /XLua，ios和android都是用lua脚本热更，基于lua虚拟机
            - C#
                - ILRuntime,未来更有前景，需要了解一下，毕竟unity官方支持。。
                    - ios用c#脚本热更（运行效率跟lua差不多），android直接用C#反射热更
        - LUA/ILRuntime热更方案都会把脚本加载到内存并执行，那么这两种方式就能正常执行动态加载的脚本呢？
            - 拿lua来举例，脚本语言工作原理：每次启动游戏的时候首先从服务器检测脚本更新，如果有更新就下载到客户端，客户端启动后，脚本会加载到内存中运行，由lua虚拟机负责解释执行脚本
            - lua热更比C#热更缺点：
                - 学习成本提高
                - 招聘成本提高
                - 引擎层到脚本层的转换会降低程序执行效率。增加lua虚拟机来执行lua脚本，增加了一层unity的C#到lua脚本的开销。
    - 小结与思考
        - unity的脚本后台有哪几种
        - 每种脚本后台分别支持哪几种编译方式
        - 安卓/苹果分别可以选择哪几种编译方式
        - C#脚本对反射的使用有限制，那么什么样反射方法可以使用呢？ 反射又是啥？
        - .net项目和netcore项目之前的区别
        - 热更新的底层原理
        - 热更新GC问题
        - 热更新的lua代码的对象绑定问题
    - 进一步学习内容
        - 资源热更新框架
            - 如何打包资源
            - 如何上传资源
            - 如何进行版本比对
            - 如何环节资源更新服务器的压力
        - 脚本热更新框架
        - lua脚本语言的学习？lua面向对象
        - ToLua/ILRuntime热更新方案及其背后各项技术的原理
            - 如何实现绑定
            - 如何实现反射
            - 如何实现重定向
    - C# 相关的自我思考问题
        - 什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？
        - 类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？
        - 在.NET程序运行过程中，什么是堆，什么是栈？什么情况下会在堆（栈）上分配数据？它们有性能上的区别吗？“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？
        - 泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。
        - 异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？
        - List<T>和T[]的区别是什么，平时你如何进行选择？Dictionary<TKey, TValue>是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？
        - 抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？
        - 字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？
        - 如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？
什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？
        - 委托是什么？匿名方法是什么？在C# 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C# 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？
        -工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？