---
layout:     post
title:      "灯泡时刻（不定期更新）"
subtitle:   "突然对某个技术点有疑问的逼技"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - 其他
---

阅读清单
- untiy游戏 C#和lua是如何交互的？
- 代码调用栈原理
- 协程底层原理
    > unity有多条渲染线程，但是对于代码的调度是在一个主线程，协程是靠操作系统在主线程的调度实现的
    - 实现原理
        - yield 相当是暂停本次生命周期执行，或者是转移控制权给unity继续生命周期
            - 每次执行到yield 暂停一下，然后下次又继续执行 如何实现？ 本质上是通过IEnumetator.MoveNext()实现的
        - 生成一个CountCoroutine的类,本质是状态机。构造方法会设置一个初始状态state为0，当state != 1 结束协程。这个类持有一个NevBehaviourScript的脚本对象，也就是为什么访问到脚本对象的各个字段
    - 协程的缺点
        - 依赖于MonoBehaviour
            - 大型商业游戏很有可能脚本不会继承自MonoBehaviour
            - MVC框架，基本只有V跟monoBehaviour打交道，M和C基本不会打交道，如果想在M或C启动协程（例：计算buff持续伤害等）就会有问题。
            - 怎么解决？实现一个自定义调度器，怎么实现？需要了解一下
        - 不能有返回值
        - 回调地狱，回调层数多了以后维护起来太复杂。。
            - 例子：如果需求是下载一张图片后下载另一张，持续很多张图片，就变成俄罗斯套娃了。
            ```
            hw.GET("xxx", (www1) =>
            {
                hw.Get("yyy", (www2)=>
                {

                });
            });

            //怎么解决，改成用 Async/Await? await什么原理?又需要去了解了。。
            await hw.Get("xxx");
            //do something
            await hw.Get("yyy");
            //do something
            ```
    - 协程有什么坑点
        - 协程的停止和创建必须用相同形式。字符串、IEnumerator、Coroutine形式
        - 禁用脚本(this.enabled = false)不会停止协程执行
        - 删除脚本（Destory(this)）或禁用GameObject会停止协程执行
- mvc?
- 模拟unity管理GameObject上Mono组件的生命周期？
    - Mono是什么？包含了实现特定脚本函数的组件类
    - 组件时什么？组件在unity中是如何实现？gameobjet是组件的容器
    - 生命周期是什么？unity 是如何管理生命周期，本质上通过遍历
    - unity 引擎是什么？管理项目中的资源+程序运行中的游戏对象树

- 快排的时间复杂度和具体实现
- 一篇英文文章，求每个单词的出现频率？算法的时间复杂度是多少？优化这个算法，能否加快这个过程？
- c#中，ArrayList和list，dictionary和hashtable区别，dictionary的底层实现原理
    - https://www.cnblogs.com/yiyi20120822/p/11429137.html
    https://www.cnblogs.com/TiestoRay/p/4891026.html
    - Dictionary与Hashtable
        - 数据结构上来说都属于Hashtable, 都是对关键字（键值）进行散列操作,将关键字散列到Hashtable的某一个槽位中去，不同的是处理碰撞的方法
        > Dictionary采用链表法处理碰撞,通过Hash算法来碰撞到指定的Bucket上，碰撞到同一个Bucket槽上所有数据形成一个单链表。
        ```
        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;
        //将HashCode的返回值转化为数组索引
        int bucketIndex = hashCode % buckets.Length;
        ```
        HashTable采用开放寻址法方法中的双重散列处理碰撞
        - dictionary
            - 有泛型优势（类型安全，性能更好），对于值类型，不存在装箱和拆箱的性能损耗
            - 读取速度快（体现在单条数据上）
            - 容量利用更充分
            - 非线程安全,多线程必须人为使用 lock 语句进行保护,  效率大减.
            - 有序（遍历时输出的顺序就是加入的顺序）
        - hashtable
            - 适合多线程
            - 通过静态方法Synchronize方法可获得完全线程安全的类型
            - 无序
    - List与Dictionary
        - List有点类似于Dictionary。二者都具有使用泛型的优点(联想到ArrayList)，Dictionary没有在内存中移动后续元素的性能开销。
        > ArrayList是可变长数组，你可以将任意多的数据Add到ArrayList里面。其内部维护的数组，当长度不足时，会自动扩容为原来的两倍。但是ArrayList也有一个缺点，就是存入ArrayList里面的数据都是Object类型的，所以如果将值类型存入和取出的时候会发生装箱、拆箱操作(就是值类型与引用类型之间的转换)，这个会影响程序性能。在.Net 2.0泛型出现以后，就提供了List<T>。List<T>是ArrayList的泛型版本，它不再需要装箱拆箱，直接取，直接用
        - List是在数组的基础上做的封装,本质是有序的动态数组，遍历查询更快(数据较多时)，Dictionary单条查询更快
        > 同样是集合，为什么性能会有这样的差距。我们要从存储结构和操作系统的原理谈起。首先我们清楚List<T>是对数组做了一层包装，我们在数据结构上称之为线性表，而线性表的概念是，在内存中的连续区域，除了首节点和尾节点外，每个节点都有着其唯一的前驱结点和后续节点。我们在这里关注的是连续这个概念。而HashTable或者Dictionary，他是根据Key和Hash算法分析产生的内存地址，因此在宏观上是不连续的，虽然微软对其算法也进行了很大的优化。由于这样的不连续，在遍历时，Dictionary必然会产生大量的内存换页操作，而List只需要进行最少的内存换页即可，这就是List和Dictionary在遍历时效率差异的根本原因。
        >> 在这里我们除了刚才的遍历问题，还要提到Dictionary的存储空间问题，在Dictionary中，除了要存储我们实际需要的Value外，还需要一个辅助变量Key，这就造成了内存空间的双重浪费。而且在尾部插入时，List只需要在其原有的地址基础上向后延续存储即可，而Dictionary却需要经过复杂的Hash计算，这也是性能损耗的地方。

- 一个数组，求前k大的数值。时间复杂度是多少。
    - 暴力法。先将数组排序（nlogn），如果是从大到小，返回第K个，如果从小到大，返回第n-k个（n表示元素个数）
    - 优先队列priorityQueue，内部实现是维护一个大小为k的最小堆。
    - 快速选择算法（快排）
- 打动态图集有什么规范？图片的压缩格式用什么？背包商店的图片怎么打成图集是最优的？动态图集的大小是怎么设定的？使用动态图集有什么缺点？图集能不能做缓存?缓存的策略是什么？
- ui框架实现了什么功能？如何管理面板层级关系，遮挡关系，互斥关系？如何做缓存策略？
- 如果ui界面打开比较慢，有可能有什么问题。
    - 第一次加载慢，什么问题？
    - 第二次加载慢？
- 一个界面打开的时候ui动画应该怎么做效率最高？
- 背包一滚动 就卡?
- 断线重连? 对于帧同步、状态同步处理方法是不一样的
    - 状态同步需要恢复游戏的状态数据。
    - 帧同步需要从第一帧开始追帧到当前最新游戏帧。如何实现？
- 战斗系统怎么实现？
    - 如果放了一个技能，如何判定对方是否收到伤害？
    - 收到伤害如何做飘出伤害文字？伤害文字怎么优化？

- 性能优化
    - GC
        - 垃圾是怎么产生的？
        - 为什么要进行垃圾收集？
        - 垃圾收集放在什么时间点比较合适？
        - 如何成代码设计的角度避免垃圾的产生？
    - 内存管理
        - 在C#中分堆内存 栈内存，有什么区别？
        - 内存中还分成mono管理（托管堆）的内存、资源内存、代码内存管理。
        - drawcall 优化
        - 耗电问题怎么优化
