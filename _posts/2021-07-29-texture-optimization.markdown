---
layout:     post
title:      "unity的贴图打包格式优化"
subtitle:   "贴图原理与优化"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - 优化
---

阅读清单
- 模型贴图
    - 模型贴图由那些构成
        - ALBEDO 漫反射
        - NORMAL  法线贴图
        - METALLIC 金属度贴图
        - ROUGHNESS 粗壮度贴图
        - AO (Ambient Occlusion) 环境光遮蔽贴图 仅黑白灰三色
- 区分图片文件格式和引擎支持的纹理格式
    - 对图片而言，诸如JPG、JPEG和PNG等多种文件格式是为了存储图像信息而使用的、对信息的特殊编码方式，它存储在磁盘中或者内存中。
    - 但图片的这些格式，对于以向量计算见长的GPU来讲就有种面对陌生外语时的“无能为力”了。
    - 3D图形硬件不支持原始的图片文件格式，原始图片需要经过CPU转换成图形硬件支持的格式才能在实时渲染中使用。而这些可以被GPU识别的格式，就是我们要说的纹理格式。
        - 不同的设备与平台具有各自专有的支持的格式
            - RGB32/RGBA32/RGBA24/RGB24为非压缩的格式，能适用于多个平台和环境
            - 目前Unity支持的纹理压缩格式有ETC、ASTC、PVRTC和DXT等

- 贴图打包流程
    - png->ETC2(比如android)->ab包->apk
- 贴图加载流程
    - 加载ab包->解包ab拿到etc2->解压生成二维数组，每个元素就是图片的rgb值，存到内存中,内存无法直接拿这些数据来渲染->加载到显存，显存进行渲染->通过GPU渲染生成帧缓存，帧缓存是最终存储将来要显示的屏幕画面。
    - android平台为什么推荐etc2，只要是2015后的显卡，支持未经过解压的ETC2格式的图片直接利用显卡生成，（跳过解压到内存，内存加载到显存的过程）
- 为什么要做贴图压缩？
    - GPU:
        - 贴图资源变小，渲染带宽占用更低
    - 包体大小:
        - 包体更小
        - 下载更快
    - 内存占用：
        - 运行时占用内存更小

- 颜色格式
    - RGB
    - RGBA
- 颜色表示，亮度值
    - LDR: 0.0~1.0
    - HDR: 0.0~无穷大 ，如太阳光，超过1.0的亮度值
- unity使用PSD/PNG/JPG格式的图片吗？
    - 不。这些格式是经过压缩的，不支持像素的随机访问，需要耗时的解压过程。比如512*512的图片，无法通过img[x][y]得到像素地址。所以unity使用texture2D这个格式，在打包的时候打包成各个平台对应的不同压缩格式。

![不同平台可以使用的贴图格式](/img/in-post/post-js-version/compressed-texture.png "不同平台可以使用的贴图格式")

- 纹理压缩的基本概念
    - 压缩比度量BPP（每个像素压缩以后所占的存储位数），每个像素压缩以后所占的存储位数越少，说明压缩比越高，占用的显存的存储容量越低，耗费显卡带宽越低，
    - 压缩算法：块压缩算法
        - 什么是块压缩算法？把每4行4列的像素点分成一个块，按块来进行压缩
        - 有何特点？ 
            - 压缩速率固定 
            - 内存压缩，所以实际在内存中的开销是减小的
        - 支持块压缩主流压缩格式的有：PC的DXT格式（DXT有1-5，常见的是1、5）、android的ETC格式
    - 压缩算法：Crunch纹理压缩。
        - 支持可变比特率压缩（取决于内容，如果内容变化比较小，压缩比就比较高，如纯红，压缩就非常非常小），压缩比率更高
        - 文件压缩，仅仅能压缩一个图片在磁盘上存储大小，但是解压以后的图片大小是跟压缩格式（etc、dxt等）有关
        - 可以不使用crunch纹理压缩，但是仍然可以使用etc 或者dxt，但是也可以为了磁盘存储大小而使用crunch纹理压缩。
- ASTC 压缩格式，更推荐，压缩比更高，把每n行n列的像素点分成一个块，按块来进行压缩,压缩快大小可调。并且支持高动态范围光照HDR，颜色值可以超过1.0

- ios平台推荐PVRTC
    - 优点：保证图片比较清晰，比较小
    - 缺点：对透明的支持不好，比如拿字符集图片，在IOS平台，默认的压缩格式是RGBA Compressed PVRTC 4 / RGB Compressed PVRTC 4。但RGBA的图片压缩后的效果看起来要比RGB的图片效果差很多，所以通常的解决办法是将带alpha通道的贴图分成两个不带通道的贴图，一张储存颜色信息，另一张存alpha值，和在安卓平台中使用ETC1时拆分RGBA贴图的处理方式一样。
    - PVRTC贴图的要求
        - 正方形的纹理
        - 2 的n次方，这个如何保证？
        - 宽、高都能被4整除
    - 和压缩方式有关，也和GPU采样效率有关。所以即便选择没有限制的压缩格式，甚至不压缩，PVRTC的限制都最好保持长宽为2的幂
- DXT 是PC主流的
    - DXT的细节上缺陷明显，原因是当把纹理分成4*4区域后，块之间是独立的，虽然简化了压缩算法，但丢失了相邻间的相似性。而PVR则会考虑区域的右侧、下侧和右下侧区域的关联性
- ETC 是android主流的
    - 与DXT方式类似，都是基于块的压缩
    - ETC1 不支持透明，需要借助一张额外的贴图存储透明信息，以及一个unity内置的shader进行透明混合
        - ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。
    - ETC2 支持透明
    - 需要二次方 长宽可不一样
- ASTC,通用支持android、ios
    - 苹果从A8处理器(iPhone6及iPad mini 4以上iOS设备支持)开始支持 ASTC
        - ASTC的质量是明显好于PVRTC的，iPhone上唯一的问题是iPhone 5s的支持。我们的方案是，如果机型不支持ASTC，会额外准备一份低质量的PVRTC的资源，尺寸是原图的一半，而设计的主要目的是解决内存问题，顺带解决iPhone 5s的压缩问题
    - 市面上大部分机型都支持OpenGL ES 3.1以上，少数GPU配置较低的机型支持OpenGL ES 3.0但不支持ASTC压缩格式，在2020年4月统计的市面占比不到1.5%，从个人角度看ASTC压缩格式是可以普及使用的。
        - astc支持率 https://answer.uwa4d.com/question/5a6700517daacf4c7ff04918
        - 国内etc2+astc是可以的，国外低端机满天飞astc不好上
    - 支持HDR
    - 支持透明
    - 压缩比高
    - 压缩快大小可调 （12 * 12 ~ 4 * 4）
    - ASTC 贴图：https://zhuanlan.zhihu.com/p/158740249
- 所以最后结论是：
    - Android：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求而且目标机型是中高端机型，使用ETC2。如果是全机型通用或者要考虑某些低端机型（如红米的部分机型），使用ECT1拆分alpha通道的方式。

    - IOS：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求，使用RGB Compressed PVRTC 4拆分alpha通道的方式。

| 压缩快大小 | bpp |
| :-----| ----: |
| 12*12 | 0.11 |
| 10*10 | 0.16 |
| 8*8 | 0.25 |
| 6*6 | 0.45 |
| 5*5 | 0.64 |
| 4*4 | 1.0  |
- 问题：ios或android手机 究竟哪些手机可以支持ASTC格式？如何在项目中运用astc？
- 回退机制
    - 如果ETC2压缩方式放在了ETC1的手机上，Unity会自己转成RGBA32或RGB32不用担心显示错误的问题。但是会与压缩的纹理一起存储在内存中，会增加纹理加载时间和增加额外内存。
    - 比如安卓手机不支持ETC2，会回退到ETC2 fallback设置的参数，例子：每个像素32位（有点太大），如何设置如下
    - 例：File-> BuildSeting->选择android平台，有个ETC2 fallback，设置32bit

- 提问
    - 尺寸大家一般是如何定的？比如1080P的全屏Loading图，一般定多少?我看王者荣耀的Loading图画质很差
        - Loading图一般是对应的设备上的压缩格式，比如安卓ETC2、iOS上ASTC，其实Loading图一般不透明，PVRTC也够用了。尺寸按照UI需求一般是和设计分辨率一致。这个也完全看缩小之后的效果UI是否满意，Loading图注意及时卸载，只增加峰值，不常驻占用，内存影响不大，包体方面一般没这么敏感。
    - 计算下面贴图的大概尺寸，并说明在不同平台你会如何选择？为什么？
        - 1024 * 1024 RGBA Compressed ETC2 8bits
        - 1024 * 1024 RGB Compressed ASTC 6 * 6 block
    - 假如有一实时战斗竞技游戏，一场战斗里，每个游戏角色需要2张1024*1024贴图，异常战斗预估最多24各角色，在苹果ASTC_RGBA(6 * 6)格式下占多大内存？
- 关于图片在运行的时占用内存大小
    - OpenGL ES 2.0支持以上提到的R5G6B5，A4R4G4B4，A1R5G5B5，R8G8B8，A8R8G8B8等纹理格式，其中R5G6B5，A4R4G4B4，A1R5G5B5每个像素占用2个字节(BYTE)，R8G8B8每个像素占用3个字节，A8R8G8B8每个像素占用4个字节。
        ![纹理格式](/img/in-post/post-js-version/texture_1.png "纹理格式")
    - 一个像素占的字节 = 位数（bit）/ 8   因为一个字节8位
    - 运行时大小 = 长 x 宽 x 每个像素占的大小
    - 举例：rgba8888 表示的是通道 rgba 每个通道都占用 8bit 那么也就是一个像素占用了 4bytes。故，图片大小若为 1014x1024，则大小=1024x1024x4/1024/1024 = 4M
- OpenGL支持非二次幂纹理的底层原理是什么？
    - 这个问题其实与GPU的寻址方式（地址对齐要求）有关，并非是图形API层面的限制
    - 在CPU当中，当要参照一张贴图的时候，你需要在程序当中给出计算地址的公式。比如，当你要访问一张宽度为w高度为h的以行优先顺序存储的贴图当中的坐标为（x，y）的贴图的时候，就需要用y*w+x来计算这个地址。对于CPU来说，它只是将这张贴图作为一个连续的内存空间处理而已。
    - 第一个因素（硬件寻址）：但是GPU不同，GPU当中完成对贴图访问（寻址以及获取数据）的模块是以硬件形式存在的。它是不可编程的，你只能从它所提供的几种方式当中选一种。
    - 第二个因素（贴图在内存上的特殊排布方式）：贴图在GPU的内存（显存）当中，一般都不是以行优先或者列优先方式存储的，而是以“块”为单位存储的
    - 第三个因素（压缩算法）：为了尽可能节约内存开销和传输带宽，贴图一般都会以一种合适的压缩格式存储，常用的压缩格式，如BC或者DXT，都是将贴图分块进行压缩。同样隐含了贴图必须是这些“块”的整数倍这样一个条件。
    - 几个因素（**硬件寻址+贴图在内存上的特殊排布方式+压缩算法要求**）决定了一款GPU在设计的时候就会将这个“块”的最小尺寸固定下来。有的GPU是2x2像素，有的是4x4像素，还有的是8x8像素。所以当贴图的尺寸不是这些“块”的整数倍的时候，当贴图被传送到GPU内存（显存）的时候，就会被拉伸或者在四周（一般是右侧和下侧）填充无用数据，使其成为这些“块”的整数倍
    - OpenGL这种抽象等级较高的图形API在易用性和可控性之间选择了易用性，也就是尽力隐藏这些细节，在其**内部为你完成必要的拉伸或者pitch的操作**，从而使得你觉得好像它支持非二次幂的纹理
- 关于 POT 和 NPOT
    - POT: 2 的幂
    - NPOT: 非 2 的幂
    - 很多人都在说图片要求 2 的幂大小啊，纹理要求 2 的幂大小之类的，我搜索了一番，发现在 opengl 或者说现代设备中基本上都已经支持了 NPOT 的形式，也就是说不必要要求纹理宽高非要是 2 的幂了。
    - 为什么untiy中的图片需要是2的N次方
        - OpenGL仅支持分辨率为2mx2n的纹理，非2的N次方的图片会转化为2的N次方的图片，这个转化的过程十分耗时
            - unity内如何将图片变成2的幂次方
                - Advanced里设置NonPower of 2 里面有4个选项，none、toNearest、toLarge、toSmall （设置比例的）推荐设置成toNearest，apply即可。
    - 使用 NPOT 效率比 POT 效率差？
        - 是的，理论上是会差点，但是相比效率的差，我们从美术角度或者程序角度再也不用去把一个 like 63x45 的美术图（本来美术这么设计的）改成 64x48 这样，因为这样在程序里纹理的内存就变大了
    - 一般来说，UI大部分会合图成POT的，3D的部分都以POT的方式设计和制作，这样整体的规范比较好制定。特殊的部分才用NPOT的，也只会影响比较少的部分
    - 一个比较老的显卡，只支持OpenGL1.1，在贴纹理的时候，长宽必须是2的n次幂，但是如果做纹理缩放，效率极为低下，且纹理失真严重，简直不可忍受。而且需要将纹理实时的贴上来，因此对效率要求比较高。有没有什么办法解决这类问题啊
        - 先建一个刚好比实际图像大的2n次幂纹理，再用glTexSubImage2D替换实际大小的部分，这个方法不知道是否可行
- 纹理优化之使用Mipmap
    - Mipmap 是啥
        - Mipmap中每个图像或级别的高度和宽度是前一级别的2的幂。Mipmap不必是正方形的。高分辨率的mipmap图像用于靠近用户的对象。当对象看起来更远时，将使用较低分辨率的图像。Mipmapping改善了渲染纹理的质量，但以占用更多内存为代价。多占用内存为原内存的1/3，为什么是1/3？
    - 既然Mipmap会额外消耗内存，那么为什么还要用Mipmap技术呢？
        - 一个核心原因是纹理大小和实际上最终图元在屏幕上显示的大小差别很大，会造成以下问题（仅在移动端下为了市场需要兼容低端机）
            - 失真
                - 举个例子：在一个屏幕内有一个视角很大、场景层次很丰富的世界场景，远山所占的屏幕显示大小很小，但是纹理贴图却很大，这时数据频率远大于采样频率，就会导致图像失真，出现摩尔纹等现象。可以理解为你想用一个点表达一张贴图里3*3或者5*5个点的颜色信息，都挤在一起。
            - GPU带宽增大，导致发热
                - 这个好理解一点，就是你同时需要渲染很多张分辨率很大的贴图，显卡当然顶不住。。。
            - 注意：现代GPU对mipmap的支持已经非常高效，开启的话会增加内存的占用，但对于带宽未必会增加，如果贴图很大且物体离屏幕稍远些，开启mipmap甚至还会提高TextureCache，减少带宽
    - 针对Mipmap的优化思路
        - UI Sprite不需要开启Mipmap
            - UI纹理通常不存在位置变化和缩放（特殊需求除外），所以UI使用的纹理都可以关闭Mipmap来节省内存
        - 对于特效贴图，粒子效果不存在频繁缩放的情况下一般不需要开启Mipmap
        - 对于3D场景物体，视角缩放范围内长期存在或者视角缩放变化不明显的物体一般不需要开启Mipmap, 如果是经常变化要开mipmap。
        - 另外有些特殊的贴图也可以不开，比如染色用的Mask通道图等等，这些从效果出发都可以满足，不一定完全按照固定的规则执行
- 选择纹理压缩格式的策略
    - 主要目的：让需要展示出高品质的纹理占用更多的资源，让那些没必要展示高品质的纹理占用占用更少的资源。
    - 尽量避免RGBA32和ARGB32纹理的使用，因为这种格式一般属于高清晰的，但也比较耗
    - RGBA16格式的加载效率也很高，接近于ETC1/PVRTC，设备越好，差距越小，因此在ETC1/PVRTC的效果不够好时，可以尝试用RGBA16
    - UI贴图要注意Mipmap和read&write属性的设置
    - 粒子贴图大小一般要在256x256以下
    - 对于模型、场景贴图，我们需要根据不同用途的贴图做不同的压缩处理
        - 举个例子？
    - 移动设备上纹理用哪些压缩格式比较好
        - 目前来讲，并不存在一个所有GPU平台都支持硬件解压的压缩格式。 ETC1 和 PVRTC 分别是Android和iOS上我们最推荐的格式。 但对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16。
        - 一般来说建议直接使用 Unity 默认的压缩格式（即选择 Compressed 即可，不需要做特殊设置），Unity 会做如下处理：
        - Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会>比 RGBA32 更节省空间，但图像的显示质量会差一些；
        - iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。
        - 另外，针对Android 上的带Alpha通道的图片，还有一种常见的做法，即把Alpha通道独立出来作为另一张纹理，从而将 RGB 部分和 Alpha 部分分别采用 ETC1来压缩，但渲染时就需要自定义的 Shader来处理。同时，我们不建议直接使用 RGBA32 格式的纹理，因为它占用了很大的内存。一般建议使用 RGBA16 和 ETC 格式的纹理来进行加载。 如果转换到 RGBA16 格式时出现了类似“色阶”的颜色问题，则建议尽可能避免大量的过渡色使用。
- 实际引用
    - 纹理资源一般可以做分档处理，最简单的可分为高中低三档，也可以根据需要加入不同的档次，依据档次来选择压缩格式；
        - 如何操作
    - 其他策略？
        - 在玩家焦点区域的纹理可以选择高清，其它区域设置为低清晰，通过动态的LOD来做优化
- 其他问题
    - 贴图设置
        - Read/Write Enable
            - 如果你不需要运行时读取图片的像素信息的话，禁用，否则启用后纹理的内存消耗会增加一倍。
                - 打开read/write enabled标签会造成贴图会在内存中被保留两份。一份在GPU显存中，一份在CPU可寻址内存（CPU-addressable memory）中。（提示：这是因为，CPU读取GPU显存是非常慢的。CPU读取显存中的一张贴图到一个临时的缓存中也不怎么现实）。在Unity中，read/write enabled的设置在默认情况下是关闭的，但可能会被意外打开。Read/Write Enabled只有在Shader以外操作贴图时，才需要被打开（比如Texture.GetPixel和Texture.SetPixel APIs），但最好避免这些操作
                - 模型中的read/write enabled标签和贴图中一样，唯一不同的是这个标签在模型中是默认开启的。
                    - 在游戏中，如果我们需要通过代码改变模型的Mesh，或者需要把Mesh赋值给MeshCollider时，Unity就会用到read/write标签。如果你不需要运行时修改模型的话，禁用，否则启用后模型的内存消耗会增加一倍。
    - 2的次方要求极端情况会导致ETC2（4的倍数要求，但考虑到如果要使用PVRTC）的内存占用变得很大，这种情况选择ETC2还是RGBA16？
        - 2的次方的要求极端情况会导致宽高都扩大接近一倍（比如：300*300往大的变会变成512*512），这样算下来多数情况如果带Alpha，512*512的ETC2-RGBA比300*300的RGBA16的内存占用还要高。
        - 话说300*300这种，你可以选择搞成256*256，但是整体肯定还是推荐压缩的格式，大部分情况下都比RGBA16要好一些（内存消耗+效果整体考虑）