---
layout:     post
title:      "unity的贴图打包格式优化"
subtitle:   "贴图原理与优化"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - 优化
---

阅读清单
- 模型贴图
    - 模型贴图由那些构成
        - ALBEDO 漫反射
        - NORMAL  法线贴图
        - METALLIC 金属度贴图
        - ROUGHNESS 粗壮度贴图
        - AO (Ambient Occlusion) 环境光遮蔽贴图 仅黑白灰三色
- ui贴图

- 贴图打包流程
    - png->ETC2(比如android)->ab包->apk
- 贴图加载流程
    - 加载ab包->解包ab拿到etc2->解压生成二维数组，每个元素就是图片的rgb值，存到内存中,内存无法直接拿这些数据来渲染->加载到显存，显存进行渲染->通过GPU渲染生成帧缓存，帧缓存是最终存储将来要显示的屏幕画面。
    - android平台为什么推荐etc2，只要是2015后的显卡，支持未经过解压的ETC2格式的图片直接利用显卡生成，（跳过解压到内存，内存加载到显存的过程）
- 为什么要做贴图压缩？
    - GPU:
        - 贴图资源变小，渲染带宽占用更低
    - 包体大小:
        - 包体更小
        - 下载更快
    - 内存占用：
        - 运行时占用内存更小

- 颜色格式
    - RGB
    - RGBA
- 颜色表示，亮度值
    - LDR: 0.0~1.0
    - HDR: 0.0~无穷大 ，如太阳光，超过1.0的亮度值
- unity使用PSD/PNG/JPG格式的图片吗？
    - 不。这些格式是经过压缩的，不支持像素的随机访问，需要耗时的解压过程。比如512*512的图片，无法通过img[x][y]得到像素地址。所以unity使用texture2D这个格式，在打包的时候打包成各个平台对应的不同压缩格式。

![不同平台可以使用的贴图格式](http://csoap.github.io/img/in-post/post-js-version/compressed-texture.png "不同平台可以使用的贴图格式")

- 纹理压缩的基本概念
    - 压缩比度量BPP（每个像素压缩以后所占的存储位数），每个像素压缩以后所占的存储位数越少，说明压缩比越高，占用的显存的存储容量越低，耗费显卡带宽越低，
    - 压缩算法：块压缩算法
        - 什么是块压缩算法？把每4行4列的像素点分成一个块，按块来进行压缩
        - 有何特点？ 
            - 压缩速率固定 
            - 内存压缩，所以实际在内存中的开销是减小的
        - 支持块压缩主流压缩格式的有：PC的DXT格式（DXT有1-5，常见的是1、5）、android的ETC格式
    - 压缩算法：Crunch纹理压缩。
        - 支持可变比特率压缩（取决于内容，如果内容变化比较小，压缩比就比较高，如纯红，压缩就非常非常小），压缩比率更高
        - 文件压缩，仅仅能压缩一个图片在磁盘上存储大小，但是解压以后的图片大小是跟压缩格式（etc、dxt等）有关
        - 可以不使用crunch纹理压缩，但是仍然可以使用etc 或者dxt，但是也可以为了磁盘存储大小而使用crunch纹理压缩。
- ASTC 压缩格式，更推荐，压缩比更高，把每n行n列的像素点分成一个块，按块来进行压缩,压缩快大小可调。并且支持高动态范围光照HDR，颜色值可以超过1.0

- ios平台推荐PVRTC
    - 优点：保证图片比较清晰，比较小
    - 缺点：对透明的支持不好，比如拿字符集图片，在IOS平台，默认的压缩格式是RGBA Compressed PVRTC 4 / RGB Compressed PVRTC 4。但RGBA的图片压缩后的效果看起来要比RGB的图片效果差很多，所以通常的解决办法是将带alpha通道的贴图分成两个不带通道的贴图，一张储存颜色信息，另一张存alpha值，和在安卓平台中使用ETC1时拆分RGBA贴图的处理方式一样。
    - PVRTC贴图的要求
        - 正方形的纹理
        - 2 的n次方，这个如何保证？
        - 宽、高都能被4整除
- DXT 是PC主流的
    - DXT的细节上缺陷明显，原因是当把纹理分成4*4区域后，块之间是独立的，虽然简化了压缩算法，但丢失了相邻间的相似性。而PVR则会考虑区域的右侧、下侧和右下侧区域的关联性
- ETC 是android主流的
    - 与DXT方式类似，都是基于块的压缩
    - ETC1 不支持透明，需要借助一张额外的贴图存储透明信息，以及一个unity内置的shader进行透明混合
        - ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。
    - ETC2 支持透明
    - 需要二次方 长宽可不一样
- ASTC,通用支持android、ios
    - 苹果从A8处理器(iPhone6及iPad mini 4以上iOS设备支持)开始支持 ASTC
    - 市面上大部分机型都支持OpenGL ES 3.1以上，少数GPU配置较低的机型支持OpenGL ES 3.0但不支持ASTC压缩格式，在2020年4月统计的市面占比不到1.5%，从个人角度看ASTC压缩格式是可以普及使用的。
    - 支持HDR
    - 支持透明
    - 压缩比高
    - 压缩快大小可调 （12 * 12 ~ 4 * 4）
    - ASTC 贴图：https://zhuanlan.zhihu.com/p/158740249
- 所以最后结论是：
    - Android：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求而且目标机型是中高端机型，使用ETC2。如果是全机型通用或者要考虑某些低端机型（如红米的部分机型），使用ECT1拆分alpha通道的方式。

    - IOS：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求，使用RGB Compressed PVRTC 4拆分alpha通道的方式。

| 压缩快大小 | bpp |
| :-----| ----: |
| 12*12 | 0.11 |
| 10*10 | 0.16 |
| 8*8 | 0.25 |
| 6*6 | 0.45 |
| 5*5 | 0.64 |
| 4*4 | 1.0 |
- 问题：ios或android手机 究竟哪些手机可以支持ASTC格式？如何在项目中运用astc？
- 回退机制
    - 如果ETC2压缩方式放在了ETC1的手机上，Unity会自己转成RGBA32或RGB32不用担心显示错误的问题。但是会与压缩的纹理一起存储在内存中，会增加纹理加载时间和增加额外内存。
    - 比如安卓手机不支持ETC2，会回退到ETC2 fallback设置的参数，例子：每个像素32位（有点太大），如何设置如下
    - 例：File-> BuildSeting->选择android平台，有个ETC2 fallback，设置32bit

- 提问
    - 计算下面贴图的大概尺寸，并说明在不同平台你会如何选择？为什么？
        - 1024 * 1024 RGBA Compressed ETC2 8bits
        - 1024 * 1024 RGB Compressed ASTC 6 * 6 block
    - 假如有一实时战斗竞技游戏，一场战斗里，每个游戏角色需要2张1024*1024贴图，异常战斗预估最多24各角色，在苹果ASTC_RGBA(6 * 6)格式下占多大内存？
- 关于图片在运行的时占用内存大小
    - OpenGL ES 2.0支持以上提到的R5G6B5，A4R4G4B4，A1R5G5B5，R8G8B8，A8R8G8B8等纹理格式，其中R5G6B5，A4R4G4B4，A1R5G5B5每个像素占用2个字节(BYTE)，R8G8B8每个像素占用3个字节，A8R8G8B8每个像素占用4个字节。
        ![纹理格式](http://csoap.github.io/img/in-post/post-js-version/texture_1.png "纹理格式")
    - 一个像素占的字节 = 位数（bit）/ 8   因为一个字节8位
    - 运行时大小 = 长 x 宽 x 每个像素占的大小
    - 举例：rgba8888 表示的是通道 rgba 每个通道都占用 8bit 那么也就是一个像素占用了 4bytes。故，图片大小若为 1014x1024，则大小=1024x1024x4/1024/1024 = 4M
- 关于 POT 和 NPOT
    - POT: 2 的幂
    - NPOT: 非 2 的幂
    - 很多人都在说图片要求 2 的幂大小啊，纹理要求 2 的幂大小之类的，我搜索了一番，发现在 opengl 或者说现代设备中基本上都已经支持了 NPOT 的形式，也就是说不必要要求纹理宽高非要是 2 的幂了。
    - 为什么untiy中的图片需要是2的N次方
        - 底层图形学只识别2的N次方的图片，OpenGL仅支持分辨率为2mx2n的纹理，非2的N次方的图片会转化为2的N次方的图片，这个转化的过程十分耗时
            - unity内如何将图片变成2的幂次方
                - Advanced里设置NonPower of 2 里面有4个选项，none、toNearest、toLarge、toSmall （设置比例的）推荐设置成toNearest，apply即可。
        - ios pvrtc的原因，有些GUP不支持NPOT，遇到NPOT会有一个转换POT的过程，浪费性能
    - 使用 NPOT 效率比 POT 效率差？
        - 是的，理论上是会差点，但是相比效率的差，我们从美术角度或者程序角度再也不用去把一个 like 63x45 的美术图（本来美术这么设计的）改成 64x48 这样，因为这样在程序里纹理的内存就变大了
    - 一个比较老的显卡，只支持OpenGL1.1，在贴纹理的时候，长宽必须是2的n次幂，但是如果做纹理缩放，效率极为低下，且纹理失真严重，简直不可忍受。而且需要将纹理实时的贴上来，因此对效率要求比较高。有没有什么办法解决这类问题啊
        - 先建一个刚好比实际图像大的2n次幂纹理，再用glTexSubImage2D替换实际大小的部分，这个方法不知道是否可行
- 纹理优化之使用Mipmap
    - Mipmap 是啥
        - Mipmap中每个图像或级别的高度和宽度是前一级别的2的幂。Mipmap不必是正方形的。高分辨率的mipmap图像用于靠近用户的对象。当对象看起来更远时，将使用较低分辨率的图像。Mipmapping改善了渲染纹理的质量，但以占用更多内存为代价。多占用内存为原内存的1/3，为什么是1/3？
    - 既然Mipmap会额外消耗内存，那么为什么还要用Mipmap技术呢？
        - 一个核心原因是纹理大小和实际上最终图元在屏幕上显示的大小差别很大，会造成以下问题（仅在移动端下为了市场需要兼容低端机）
            - 失真
                - 举个例子：在一个屏幕内有一个视角很大、场景层次很丰富的世界场景，远山所占的屏幕显示大小很小，但是纹理贴图却很大，这时数据频率远大于采样频率，就会导致图像失真，出现摩尔纹等现象。可以理解为你想用一个点表达一张贴图里3*3或者5*5个点的颜色信息，都挤在一起。
            - GPU带宽增大，导致发热
                - 这个好理解一点，就是你同时需要渲染很多张分辨率很大的贴图，显卡当然顶不住。。。
            - 注意：现代GPU对mipmap的支持已经非常高效，开启的话会增加内存的占用，但对于带宽未必会增加，如果贴图很大且物体离屏幕稍远些，开启mipmap甚至还会提高TextureCache，减少带宽
    - 针对Mipmap的优化思路
        - UI Sprite不需要开启Mipmap
            - UI纹理通常不存在位置变化和缩放（特殊需求除外），所以UI使用的纹理都可以关闭Mipmap来节省内存
        - 对于特效贴图，粒子效果不存在频繁缩放的情况下一般不需要开启Mipmap
        - 对于3D场景物体，视角缩放范围内长期存在或者视角缩放变化不明显的物体一般不需要开启Mipmap。
- 其他问题
    - 贴图设置
        - Read/Write Enable
            - 如果你不需要运行时读取图片的像素信息的话，禁用，否则启用后纹理的内存消耗会增加一倍。 
                - 打开read/write enabled标签会造成贴图会在内存中被保留两份。一份在GPU显存中，一份在CPU可寻址内存（CPU-addressable memory）中。（提示：这是因为，CPU读取GPU显存是非常慢的。CPU读取显存中的一张贴图到一个临时的缓存中也不怎么现实）。在Unity中，read/write enabled的设置在默认情况下是关闭的，但可能会被意外打开。Read/Write Enabled只有在Shader以外操作贴图时，才需要被打开（比如Texture.GetPixel和Texture.SetPixel APIs），但最好避免这些操作
                - 模型中的read/write enabled标签和贴图中一样，唯一不同的是这个标签在模型中是默认开启的。
                    - 在游戏中，如果我们需要通过代码改变模型的Mesh，或者需要把Mesh赋值给MeshCollider时，Unity就会用到read/write标签。如果你不需要运行时修改模型的话，禁用，否则启用后模型的内存消耗会增加一倍。