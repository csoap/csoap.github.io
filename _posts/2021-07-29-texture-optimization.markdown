---
layout:     post
title:      "unity的贴图打包格式优化"
subtitle:   "贴图原理与优化"
date:       2019-11-29
author:     "CSoap"
header-img: "img/home-bg-o.jpg"
tags:
    - 优化
---

阅读清单
- 模型贴图
    - 模型贴图由那些构成
        - ALBEDO 漫反射
        - NORMAL  法线贴图
        - METALLIC 金属度贴图
        - ROUGHNESS 粗壮度贴图
        - AO (Ambient Occlusion) 环境光遮蔽贴图 仅黑白灰三色
- ui贴图

- 贴图打包流程
    - png->ETC2(比如android)->ab包->apk
- 贴图加载流程
    - 加载ab包->解包ab拿到etc2->解压生成二维数组，每个元素就是图片的rgb值，存到内存中,内存无法直接拿这些数据来渲染->加载到显存，显存进行渲染->通过GPU渲染生成帧缓存，帧缓存是最终存储将来要显示的屏幕画面。
    - android平台为什么推荐etc2，只要是2015后的显卡，支持未经过解压的ETC2格式的图片直接利用显卡生成，（跳过解压到内存，内存加载到显存的过程）
- 为什么要做贴图压缩？
    - GPU:
        - 贴图资源变小，渲染带宽占用更低
    - 包体大小:
        - 包体更小
        - 下载更快
    - 内存占用：
        - 运行时占用内存更小

- 颜色格式
    - RGB
    - RGBA
- 颜色表示，亮度值
    - LDR: 0.0~1.0
    - HDR: 0.0~无穷大 ，如太阳光，超过1.0的亮度值
- unity使用PSD/PNG/JPG格式的图片吗？
    - 不。这些格式是经过压缩的，不支持像素的随机访问，需要耗时的解压过程。比如512*512的图片，无法通过img[x][y]得到像素地址。所以unity使用texture2D这个格式，在打包的时候打包成各个平台对应的不同压缩格式。

![不同平台可以使用的贴图格式](http://csoap.github.io/img/in-post/post-js-version/compressed-texture.png "不同平台可以使用的贴图格式")

- 纹理压缩的基本概念
    - 压缩比度量BPP（每个像素压缩以后所占的存储位数），每个像素压缩以后所占的存储位数越少，说明压缩比越高，占用的显存的存储容量越低，耗费显卡带宽越低，
    - 压缩算法：块压缩算法
        - 什么是块压缩算法？把每4行4列的像素点分成一个块，按块来进行压缩
        - 有何特点？ 
            - 压缩速率固定
            - 内存压缩，所以实际在内存中的开销是减小的
        - 支持块压缩主流压缩格式的有：PC的DXT格式（DXT有1-5，常见的是1、5）、android的ETC格式
    - 压缩算法：Crunch纹理压缩。
        - 支持可变比特率压缩（取决于内容，如果内容变化比较小，压缩比就比较高，如纯红，压缩就非常非常小），压缩比率更高
        - 文件压缩，仅仅能压缩一个图片在磁盘上存储大小，但是解压以后的图片大小是跟压缩格式（etc、dxt等）有关
        - 可以不使用crunch纹理压缩，但是仍然可以使用etc 或者dxt，但是也可以为了磁盘存储大小而使用crunch纹理压缩。
- ASTC 压缩格式，更推荐，压缩比更高，把每n行n列的像素点分成一个块，按块来进行压缩,压缩快大小可调。并且支持高动态范围光照HDR，颜色值可以超过1.0

- ios平台推荐PVRTC
    - 优点：保证图片比较清晰，比较小
    - 缺点：对透明的支持不好，比如拿字符集图片，在IOS平台，默认的压缩格式是RGBA Compressed PVRTC 4 / RGB Compressed PVRTC 4。但RGBA的图片压缩后的效果看起来要比RGB的图片效果差很多，所以通常的解决办法是将带alpha通道的贴图分成两个不带通道的贴图，一张储存颜色信息，另一张存alpha值，和在安卓平台中使用ETC1时拆分RGBA贴图的处理方式一样。
    - PVRTC贴图的要求
        - 正方形的纹理
        - 2 的n次方，这个如何保证？
        - 宽、高都能被4整除
- DXT 是PC主流的
- ETC 是android主流的
    - 与DXT方式类似，都是基于块的压缩
    - ETC1 不支持透明，需要借助一张额外的贴图存储透明信息，以及一个unity内置的shader进行透明混合
        - ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。
    - ETC2 支持透明
    - 需要二次方 长宽可不一样
- ASTC,通用支持android、ios
    - 苹果从A8处理器(iPhone6及iPad mini 4以上iOS设备支持)开始支持 ASTC
    - 市面上大部分机型都支持OpenGL ES 3.1以上，少数GPU配置较低的机型支持OpenGL ES 3.0但不支持ASTC压缩格式，在2020年4月统计的市面占比不到1.5%，从个人角度看ASTC压缩格式是可以普及使用的。
    - 支持HDR
    - 支持透明
    - 压缩比高
    - 压缩快大小可调 （12 * 12 ~ 4 * 4）
    - ASTC 贴图：https://zhuanlan.zhihu.com/p/158740249
- 所以最后结论是：
    - Android：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求而且目标机型是中高端机型，使用ETC2。如果是全机型通用或者要考虑某些低端机型（如红米的部分机型），使用ECT1拆分alpha通道的方式。

    - IOS：如果对贴图质量要求高比如某些UI，使用RGBA32/RGB32。如果对质量无特殊要求，使用RGB Compressed PVRTC 4拆分alpha通道的方式。

| 压缩快大小 | bpp |
| :-----| ----: |
| 12*12 | 0.11 |
| 10*10 | 0.16 |
| 8*8 | 0.25 |
| 6*6 | 0.45 |
| 5*5 | 0.64 |
| 4*4 | 1.0 |
- 问题：ios或android手机 究竟哪些手机可以支持ASTC格式？如何在项目中运用astc？
- 回退机制
    比如安卓手机不支持ETC2，会回退到ETC2 fallback设置的参数，例子：每个像素32位（有点太大），如何设置如下
    - 例：File-> BuildSeting->选择android平台，有个ETC2 fallback，设置32bit

- 提问
    - 计算下面贴图的大概尺寸，并说明在不同平台你会如何选择？为什么？
        - 1024 * 1024 RGBA Compressed ETC2 8bits
        - 1024 * 1024 RGB Compressed ASTC 6 * 6 block
    - 假如有一实时战斗竞技游戏，一场战斗里，每个游戏角色需要2张1024*1024贴图，异常战斗预估最多24各角色，在苹果ASTC_RGBA(6 * 6)格式下占多大内存？

- 纹理优化之使用Mipmap
    - Mipmap 是啥
        - Mipmap中每个图像或级别的高度和宽度是前一级别的2的幂。Mipmap不必是正方形的。高分辨率的mipmap图像用于靠近用户的对象。当对象看起来更远时，将使用较低分辨率的图像。Mipmapping改善了渲染纹理的质量，但以占用更多内存为代价。多占用内存为原内存的1/3，为什么是1/3？
    - 既然Mipmap会额外消耗内存，那么为什么还要用Mipmap技术呢？
        - 一个核心原因是纹理大小和实际上最终图元在屏幕上显示的大小差别很大，会造成以下问题（仅在移动端下为了市场需要兼容低端机）
            - 失真
                - 举个例子：在一个屏幕内有一个视角很大、场景层次很丰富的世界场景，远山所占的屏幕显示大小很小，但是纹理贴图却很大，这时数据频率远大于采样频率，就会导致图像失真，出现摩尔纹等现象。可以理解为你想用一个点表达一张贴图里3*3或者5*5个点的颜色信息，都挤在一起。
            - GPU带宽增大，导致发热
                - 这个好理解一点，就是你同时需要渲染很多张分辨率很大的贴图，显卡当然顶不住。。。
            - 注意：现代GPU对mipmap的支持已经非常高效，开启的话会增加内存的占用，但对于带宽未必会增加，如果贴图很大且物体离屏幕稍远些，开启mipmap甚至还会提高TextureCache，减少带宽
    - 针对Mipmap的优化思路
        - UI Sprite不需要开启Mipmap
            - UI纹理通常不存在位置变化和缩放（特殊需求除外），所以UI使用的纹理都可以关闭Mipmap来节省内存
        - 对于特效贴图，粒子效果不存在频繁缩放的情况下一般不需要开启Mipmap
        - 对于3D场景物体，视角缩放范围内长期存在或者视角缩放变化不明显的物体一般不需要开启Mipmap。
        - 
- 其他问题